# Nomenclature

- **TEE**: Trusted Execution Environment  
  A secure area of a processor that ensures the confidentiality and integrity of code and data inside it, even from privileged users like the operating system.

- **USM**: Untrusted State Machine  
  The storage component in Nimble that is not trusted but stores all ledger data; relies on cryptographic methods to ensure data integrity.

- **Nonce**: Number used once  
  A random number provided by the client to ensure the freshness of data during read operations.

- **Quorum**: A majority of endorsers (n/2 + 1)  
  The minimum number of endorsers needed to validate and process requests securely.

- **Endorser**: Trusted state machine running in a TEE  
  Ensures the integrity and freshness of the ledger by holding the tail of the ledger and signing operations.

- **Append-only Ledger**: Immutable log  
  A storage structure where new data can only be appended, not modified or deleted, ensuring a tamper-proof record.

- **Tail**: The most recent entry in the append-only ledger  
  Represents the latest block in the chain of the ledger, stored and signed by endorsers.

- **Coordinator**: Manages interaction between client, endorsers, and USM  
  Ensures that requests are processed, receipts are generated, and handles reconfiguration when needed.

- **Receipt**: Cryptographic proof  
  A signed object from a quorum of endorsers, ensuring that an operation (append or read) was executed correctly and in the proper order.

- **Remote Attestation**: Verifying TEE code  
  A process where the client verifies that the correct and expected code is running inside the TEE through cryptographic proofs.

- **Reconfiguration**: Process of replacing or adding endorsers  
  A secure protocol to finalize old endorsers and activate new ones without compromising the safety or liveness of the system.

- **Finalization**: End of an endorser's life  
  When an endorser is about to be replaced, it signs and sends its final state and erases its keys.

- **Linearizability**: Strong consistency model  
  Ensures that operations appear to happen atomically in an order consistent with real-time.

- **Freshness**: Guarantee that data is up-to-date  
  Ensures that the most recent version of data is returned, preventing rollback attacks.

- **Rollback Attack**: Replay of older data  
  A type of attack where an old, valid version of data is presented as the current state to trick the system.

- **SHA-256**: Secure Hash Algorithm 256-bit  
  A cryptographic hash function used to ensure data integrity by producing a fixed-size hash from arbitrary input.

- **ECDSA P-256**: Elliptic Curve Digital Signature Algorithm  
  A cryptographic algorithm used by Nimble for signing and verifying operations securely.

- **Crash Fault Tolerance**: Ability to recover from crashes  
  Ensures that if components (e.g., endorsers) crash, the system can recover and continue operating without losing data integrity.

- **Append_with_read_latest**: API that appends and reads atomically  
  Ensures that appending and reading data can happen as a single atomic operation to guarantee consistency.

- **Activate**: API that turns on new endorsers  
  Used to bring new endorsers online after verifying they are initialized with the correct state.

- **Partitioning**: Dividing ledgers among endorsers  
  A strategy to improve performance and fault tolerance by assigning sections of the ledger to different endorsers.

- **P-256**: NIST standard elliptic curve  
  Used in cryptographic signatures for ensuring secure communication and verifying data integrity.

- **Snapshot**: A saved state of the system  
  Used for disaster recovery to recreate endorsers if they fail completely and need to be restored.

- **Liveness**: Property that ensures progress  
  Ensures that as long as a quorum of endorsers is operational, the system continues to function and process requests.

# Nimble Protocol

Nimble is a secure, append-only ledger protocol designed to ensure data integrity and protect against rollback attacks in environments using Trusted Execution Environments (TEEs). 

## Overview

TEEs are not state-persistent, which requires applications to manage their state independently. This limitation exposes applications to potential rollback attacks, such as brute-forcing PINs by crashing the app after reaching the attempt limit.

### Key Features of Nimble

- **Append-Only Ledger**: Data can be read and written but not deleted, preserving the integrity of previous operations.
- **Nonce Usage**: When reading from the ledger, a nonce is provided, which is used by the endorser to ensure the freshness of the response.
- **Rollback Attack Prevention**: Endorsers lack the ability to perform rollback operations, thereby reducing the risk of such attacks.
- **Trusted State Machines**: Endorsers are designed to store tails and hashes of each ledger part to verify storage integrity.
- **Crash Recovery**: Multiple endorsers provide redundancy and help with recovery in case of failures.

## Initialization

1. A coordinator initializes a configured number of endorsers.
2. For each request, the coordinator interacts with the Untrusted State Machine (USM) and the endorsers.
3. A response is considered valid when a quorum of endorsers (n/2 + 1) returns the same result. Non-responsive endorsers may be out of sync and are rolled forward to catch up.

## Liveness

- The coordinator creates API requests to the correct thread; endorsers return receipts with signatures.
- Receipts are saved by the coordinator and used to execute requests via the USM and endorsers.
- If creating a receipt fails after a certain number of attempts, the `append_with_read_latest` API is used to execute both operations atomically.

## Replacing Endorsers

If there aren't enough endorsers, requests may fail. Nimble can retire old endorsers and create new ones while ensuring security:

- Two disjoint sets (existing and new endorsers) are maintained.
- The keys of new endorsers are stored in a read-only ledger accessible to any coordinator.
- Finalized endorsers erase their keys and can no longer accept requests but send a final signature and state to ensure liveliness.

### Activation of New Endorsers

- To initialize a new set, state is transferred to the new endorsers (set N).
- The safety of activation is verified through:
  - Ensuring the existing set (E) is finalized.
  - Confirming that set N has been initialized with the same state.
  - Verifying that set N is derived from E.

## Implementations

- **Coordinator**: Untrusted, written in Rust.
- **Endorser**: Trusted, written in Rust and C++ (for core protocols).
- **Endpoint**: Trusted, written in Rust.
- The C++ endorser is limited to core protocol functionality.
- Clients use a VPN client for remote access and secure channel creation.
- The endpoint processes requests via a REST API.

## Evaluation

Nimble demonstrates significant throughput, primarily limited by crypto operations and storage bottlenecks, rather than by the protocol itself. Its simplicity allows for easier security proofs compared to more complex systems.

## Related Work

### Sealing

Sealing utilizes secret keys to encrypt data before storage and counters to prevent rollback but may suffer from performance issues. Nimble addresses these challenges by introducing multiple replicas and reconfiguration capabilities.

### Disaster Recovery

If a majority of endorsers are lost:
- Simple disconnection leads to offline status until quorum access is restored.
- If endorsers are completely lost, the system halts.

The reconfiguration protocol helps maintain a constant number of endorsers and can facilitate reallocation to different locations during disasters.

## Terms

- **Remote Attestation**: Allows clients to verify the integrity of the code running within the TEE.
- **Rollback Attack**: Exploiting the system by resending old messages to induce errors or undesired actions.

Each new block in the ledger records its position, allowing the application to check for correctness against previous ledger entries. 

## References

- [Nimble Paper](https://drive.google.com/file/d/1nQcPXvW1tv7B5lgOoxjP9lBQcRJ4cR0o/view?usp=sharing)
- [Nimble GitHub Code](https://github.com/Microsoft/Nimble)
- [Praktikum Google Drive](https://drive.google.com/drive/folders/1DiloQRCfFniMYOTE23AkozAO3LwMdSKD?usp=sharing)

## Components of Nimble

### 1. Client
**Role:** The client represents the entity (an application running in a TEE) that interacts with Nimble for storing and retrieving data in a way that is protected from rollback attacks.

**How it works:**
- The client makes requests to store or retrieve state from Nimble's append-only ledger.
- A nonce (a random value) is provided when reading data to ensure freshness.
- The client receives signed receipts from Nimble, proving the integrity and freshness of the data.

**Technical details:** 
- The client operates over a secure channel and performs cryptographic verification using ECDSA (P-256) to ensure that the state returned is valid and current.

### 2. Coordinator
**Role:** The coordinator manages the overall operation of the Nimble system, acting as an intermediary between the client, endorsers, and storage.

**How it works:**
- When a client issues a request (e.g., append or read), the coordinator forwards this request to both the Untrusted State Machine (USM) and endorsers.
- It collects responses from a quorum of endorsers (n/2 + 1) and aggregates them into a single response sent back to the client.
- The coordinator also manages reconfiguration by adding or removing endorsers when necessary.

**Liveness:** 
- The coordinator ensures liveness by retrying operations if endorsers crash and rolling endorsers forward if they lag behind during reconfiguration.

**Technical details:**
- Written in Rust, the coordinator handles API requests and stores receipts in the USM for recovery. It operates statelessly, allowing it to crash and recover by reloading state from the USM.

### 3. Endorser
**Role:** Endorsers are the core trusted components of Nimble, running inside TEEs. They maintain the integrity and freshness of the ledger.

**How it works:**
- Each endorser stores the current state (tail) of the ledger and appends new data as requested by the client via the coordinator.
- For each append or read request, the endorser signs a response with its secret key to verify both the current state and the nonce provided by the client.
- Endorsers work in a quorum to ensure fault tolerance, meaning that as long as a majority (n/2 + 1) are live, Nimble continues to function.

**Technical details:**
- Implemented in Rust and C++ (for core protocols), endorsers run inside trusted execution environments (e.g., Intel SGX or AMD SEV-SNP). Their state is volatile, meaning if they crash, they lose their memory. Endorsers do not have rollback APIs.

### 4. Endpoint
**Role:** The endpoint is a trusted intermediary that helps the client interact with Nimble securely and verifiably.

**How it works:**
- The endpoint runs inside a confidential VM and provides a REST API for clients to issue requests to Nimble.
- It manages client-side logic for verifying signatures and ensures that the correct endorsers and coordinator respond.

**Technical details:**
- The endpoint uses cryptographic libraries (e.g., OpenSSL) for secure communication and verification, ensuring a secure channel between the client and the endorsers.

### 5. Untrusted State Machine (USM)
**Role:** The USM serves as the crash fault-tolerant storage service for Nimble, ensuring data persistence even if endorsers or the coordinator crash.

**How it works:**
- All ledger data is stored in the USM, which provides APIs like put, get, and append.
- The USM is untrusted, meaning it does not run inside a TEE, but cryptographic techniques ensure the data cannot be tampered with.

**Technical details:**
- The USM can be implemented using cloud storage services (e.g., Azure Table) or in-memory key-value stores, key to ensuring Nimbleâ€™s liveness by reliably storing state.

### 6. Ledger (Append-only Log)
**Role:** The append-only ledger is where all data (state) is stored in Nimble, with integrity and freshness guaranteed by endorsers.

**How it works:**
- Each time the client writes data to Nimble, a new block is created in the ledger structured as a hash chain.
- Each block contains data and a cryptographic hash of the previous block, ensuring that no previous block can be modified without invalidating the entire chain.

**Technical details:**
- The ledger uses cryptographic primitives (e.g., SHA-256 for hashes, ECDSA P-256 for signatures) to secure data, with endorsers storing the tails of the ledgers and signing operations for integrity.

### 7. Reconfiguration Protocol
**Role:** This protocol ensures Nimble can add, remove, or replace endorsers without compromising safety or liveness.

**How it works:**
- The coordinator triggers the reconfiguration protocol when an endorser needs to be replaced.
- The current set of endorsers is finalized, and a new set is initialized with the current state.

**Technical details:**
- The protocol is secure, maintaining disjoint sets of old and new endorsers. Each new endorser set is verified to ensure they start from the latest correct state.

### 8. Receipts
**Role:** Receipts are cryptographic proofs provided by Nimble to verify that a particular operation (e.g., append or read) was executed correctly.

**How it works:**
- After an operation, Nimble returns a receipt including signatures from a quorum of endorsers, ensuring the operation was performed on the most recent ledger state.

**Technical details:**
- Receipts are created using the P-256 ECDSA signature scheme, and clients or endpoints verify them to ensure valid responses.
